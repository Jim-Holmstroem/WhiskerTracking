The testing implementation was developed with high modularity in mind, since is meant to be a proof-of-concept implementation and not a production grade system. High modularity also makes development easier and the system more robust against changes, two very important qualities for this project.


The implementation consists of three main parts:
\begin{description}
  \item[Particle Filter] An implementation of the procedure in table \ref{pf-algorithm}.
  \item[Database] A database with functions for extracting transition hypotheses. Provides the prediction probability function $\cprobnext{x}$ to the particle filter.
  \item[Tracker] Manages the model and performs matching between hypotheses and images. Provides the filtering probability function $\cprob{I_n}{x_n}$ to the particle filter.
\end{description}




\section{The particle filter}
    A plug-n-play algorithm which only lacks the problem-domain<ref:encyc> specific parts:$x_0$, $\cprob{x_t}{x_{t-1}}$ and $\cprob{I_t}{x_t}$
    \subsection{Initilization $x_0$}
        The particle filter only does tracking thus we need to have an initial guess for $t=0$ which in our case will be hand labeled foreach whisker.
    \subsection{Goodness $\kappa\cprob{x_t}{I_t}$}
        It also needs an direction to know how good the hypothesis $x_t$ matches the given image $I_t$.

        TODO <ref:theorem>
    \subsection{Sampling $\cprobnext{x}$}

        ...

\section{The state transition database}





\section{Real data}
    \subsection{Pre-processing}

    We want to find the function $\prob{I=\text{whisker}}$

    >We want to have a measure on how probable it is for a pixel to hosehould a whisker





